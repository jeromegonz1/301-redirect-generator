# US012 - Matching Cloisonné par Langue

## 📋 Contexte
Pour préserver la cohérence SEO et éviter les erreurs de redirection, le matching (IA ou manuel) ne doit se faire qu'entre URLs de même langue.

## 🎯 User Story

**En tant que** responsable SEO multilingue,  
**je veux** que le matching IA et manuel se fasse uniquement à l'intérieur d'un même groupe de langue détecté,  
**afin d'** éviter les redirections incorrectes entre langues (ex: FR→EN, ES→DE).

## ✅ Critères d'acceptation

### Cloisonnement strict
- [ ] Matching FR ancien → FR nouveau uniquement
- [ ] Matching EN ancien → EN nouveau uniquement  
- [ ] Interdiction totale de correspondances inter-langues
- [ ] Gestion séparée de chaque groupe linguistique

### Interface cloisonnée
- [ ] Onglets ou sections par langue dans l'interface
- [ ] Validation indépendante pour chaque langue
- [ ] Statistiques séparées par groupe linguistique
- [ ] Export cloisonné par langue

### Gestion des déséquilibres
- [ ] Alertes pour langues avec 0 correspondance possible
- [ ] Suggestion automatique de fallbacks 302
- [ ] Option de désactivation du matching pour certaines langues
- [ ] Rapport des URLs orphelines par langue

## 🏗️ Architecture de cloisonnement

### Groupement initial
```python
# Étape 1: Groupement par langue
old_urls_grouped = {
    'fr': ['/fr/contact', '/fr/services', ...],
    'en': ['/en/contact', '/en/about', ...],
    'de': ['/de/kontakt', '/de/services', ...],
    'es': ['/es/contacto', '/es/servicios', ...]
}

new_urls_grouped = {
    'fr': ['/fr/contact-nous', '/fr/nos-services', ...],
    'en': ['/en/contact-us', '/en/our-services', ...],
    'de': ['/de/kontakt-uns', '/de/unsere-services', ...],
    'es': []  # Langue non migrée
}
```

### Matching par langue
```python
# Étape 2: Matching indépendant par langue
for language in ['fr', 'en', 'de']:
    if language in new_urls_grouped:
        matches = ai_match(
            old_urls=old_urls_grouped[language],
            new_urls=new_urls_grouped[language],
            language=language
        )
    else:
        # Langue absente → Fallback 302
        fallbacks = generate_302_fallbacks(
            old_urls=old_urls_grouped[language],
            target='/fr/'
        )
```

## 🎨 Interface utilisateur

### Navigation par langue
```
🌍 Matching par langue

📑 Onglets:
[🇫🇷 FR (400→300)] [🇬🇧 EN (200→150)] [🇩🇪 DE (100→99)] [🇪🇸 ES (80→0)]

--- Onglet FR actif ---
✅ Matching IA disponible (300 nouvelles URLs)
📊 Correspondances trouvées : 275/400
🔍 25 URLs sans correspondance → Fallback /fr/

[Tableau de validation pour URLs FR uniquement]
```

### Statistiques par langue
```
📊 Tableau de bord multilingue

┌─────────┬──────────────┬───────────────┬──────────────┬─────────────┐
│ Langue  │ Ancien site  │ Nouveau site  │ Matchées IA  │ Fallbacks   │
├─────────┼──────────────┼───────────────┼──────────────┼─────────────┤
│ 🇫🇷 FR   │ 400          │ 300           │ 275          │ 25          │
│ 🇬🇧 EN   │ 200          │ 150           │ 140          │ 60          │
│ 🇩🇪 DE   │ 100          │ 99            │ 95           │ 5           │
│ 🇪🇸 ES   │ 80           │ 0             │ 0            │ 80 (302)    │
└─────────┴──────────────┴───────────────┴──────────────┴─────────────┘
```

## 🔧 Spécifications techniques

### Classe LanguageMatchingEngine
```python
class LanguageMatchingEngine:
    def __init__(self, ai_mapper: AIMapper, detector: LanguageDetector):
        self.ai_mapper = ai_mapper
        self.detector = detector
    
    def match_by_language(self, old_urls: List[str], new_urls: List[str]) -> Dict[str, MatchResult]:
        """Effectue le matching cloisonné par langue"""
        
    def generate_language_report(self) -> LanguageReport:
        """Génère un rapport par langue"""
        
    def export_by_language(self, language: str) -> Tuple[str, str]:
        """Exporte .htaccess et CSV pour une langue spécifique"""
```

### Algorithme de cloisonnement
```python
def match_by_language(old_urls, new_urls):
    results = {}
    
    # Groupement par langue
    old_grouped = detector.group_by_language(old_urls)
    new_grouped = detector.group_by_language(new_urls)
    
    for language in old_grouped.keys():
        if language in new_grouped:
            # Matching IA normal
            results[language] = ai_mapper.match_urls(
                old_urls=old_grouped[language],
                new_urls=new_grouped[language],
                language=language
            )
        else:
            # Langue absente → Fallback
            results[language] = generate_fallback_302(
                old_urls=old_grouped[language],
                target=f'/{DEFAULT_LANGUAGE}/'
            )
    
    return results
```

## 🧪 Scénarios de test

### Test 1: Cloisonnement strict
```
Donné:
- FR ancien: ['/fr/contact', '/fr/services']
- EN ancien: ['/en/about', '/en/pricing']
- FR nouveau: ['/fr/contact-nous']
- EN nouveau: ['/en/about-us']

Attendu:
- /fr/contact → /fr/contact-nous (FR→FR uniquement)
- /en/about → /en/about-us (EN→EN uniquement)
- Aucune correspondance FR→EN ou EN→FR
```

### Test 2: Langue manquante
```
Donné:
- ES ancien: ['/es/contacto', '/es/servicios']
- ES nouveau: [] (vide)

Attendu:
- Toutes les URLs ES → Fallback 302 vers /fr/
- Aucun matching IA tenté pour ES
```

### Test 3: Déséquilibre numérique
```
Donné:
- EN ancien: 200 URLs
- EN nouveau: 50 URLs

Attendu:
- 50 meilleures correspondances IA
- 150 URLs → Fallback 302 vers /en/ (home anglaise)
```

## 📊 Métriques par langue

### Dashboard détaillé
```
🎯 Performance du matching cloisonné

🇫🇷 Français (Langue principale):
├── Taux de matching: 89% (275/309)
├── Confidence moyenne: 0.87
└── Temps de traitement: 45s

🇬🇧 Anglais (Langue secondaire):
├── Taux de matching: 70% (140/200)
├── Confidence moyenne: 0.81
└── Temps de traitement: 32s

🇪🇸 Espagnol (Non migré):
├── Taux de matching: 0% (fallback total)
├── URLs concernées: 80
└── Redirection: 302 → /fr/
```

### Alertes qualité
- 🟡 **Déséquilibre** : Langue avec < 50% de matching possible
- 🔴 **Critique** : Langue principale avec < 80% de matching
- ℹ️ **Info** : Langues non migrées avec fallback 302

## 🚫 Exclusions

- Matching automatique inter-langues (strictement interdit)
- Translation automatique entre langues
- Détection du contenu pour améliorer le matching (US011 uniquement)
- Interface de validation globale (US010 reste multilingue)

## 🔄 Statut
**🔄 À développer** - Engine de matching avec cloisonnement linguistique

---

*US012 développée pour SEPTEO Digital Services*  
*Matching cloisonné par langue pour SEO multilingue*